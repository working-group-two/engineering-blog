---
layout: blogpost
permalink: /blog/mqtt-event-bridge
title: "Changing the color of your bulbs: The fancy way"
date: 2021-01-07
tags: api grpc mqtt node-red
author: <a href="https://www.linkedin.com/in/gunnaringe/">Gunnar Inge G. Sortland</a> - Software Engineer
---

There are a variety of events generated by Working Group Two’s systems for subscriptions on the platform. This includes information such as call events, SMS sent to and from a subscription (including content), voicemail events, location events, and more.

We offer a [gRPC API](https://docs.wgtwo.com/events/how-to/listen-for-events/) which enables developers to listen to a selection of these events.

I wanted to make a super simple setup so that I could configure home automation rules, e.g. **"If someone calls me, make my IKEA bulb change color to notify me"** or **"If I send myself a SMS with 'Leaf ON', turn on the heater in my car"**.

A lot of home automation tools, such as Node-RED and Home Assistant have great MQTT support, so instead of writing a native gRPC integration I wanted to make a more flexible solution by offering these events over MQTT. This way, anyone using a home automation tool with MQTT support can integrate with our platform easily.

During our last hackathon I built a simple bridge between our events API and MQTT. I wrote this bridge in Go, using [Mochi MQTT](https://github.com/mochi-co/mqtt) as an embedded MQTT server.

The way it works is quite simple: You log in to the service using our OAuth solution. You then grant the service access to fetch events on your behalf. The service will then generate a username and password for you.

The MQTT/gRPC events-bridge will fetch events for all subscribers that have enabled it, and publish these to the topic `{phone number}/events/{type}`.

The generated credentials will then allow you to listen any topic matching `{phone number}/#`.

Note that nothing of this requires any setup on your phone, so it would work equally well on a 20-30 year old Nokia phone.

## Connecting to Working Group Two's API

We will use a normal OAuth2 authorization code grant for logging in to our service.

To handle this, we used the module `github.com/markbates/goth` with the following settings:

```go
import "golang.org/x/oauth2"

const endpointProfile string = "https://id.wgtwo.com/userinfo"

var Endpoint = oauth2.Endpoint{
  AuthURL:  "https://id.wgtwo.com/oauth2/auth",
  TokenURL: "https://id.wgtwo.com/oauth2/token",
}
```

When logging in, the user will be asked to consent to the following scopes:
- phone: Allowing the service to fetch the user’s phone number
- offline_access: Giving the service a refresh token
- events.voice.subscribe: Allow the service to see all call events
- events.voicemail.subscribe: Allow the service to see if a voicemail has been left
- events.sms.subscribe: Allow the service to get a copy of every SMS sent and received

All the events you have consented to share with the service will be stored in the service's queue.

```
sms events        ─╮
voice events      ─┼─▷  queue  ◁── gRPC API
voice mail events ─╯
```

This queue can be consumed by using the events streaming API ([docs](https://docs.wgtwo.com/events/how-to/listen-for-events/)), which requires the service to use the OAuth2 client credentials grant flow.

Events will be shared with the service as long as there exists an active consent.

We then initiate the server side stream to fetch the events:
```go
request := &pb.SubscribeEventsRequest{
  Type:          []pb.EventType{pb.EventType_VOICEMAIL_EVENT},
  StartPosition: &pb.SubscribeEventsRequest_StartAtOldestPossible{},
  ClientId:      uuid.New().String(),
  QueueName:     "wgtwo-mqtt-demo",
  DurableName:   "wgtwo-mqtt-demo",
  MaxInFlight:   10,
  ManualAck: &pb.ManualAckConfig{
     Enable:  true,
     Timeout: ptypes.DurationProto(10 * time.Second),
  },
}
r, err := c.Subscribe(context.TODO(), request)

for {
  response, err := r.Recv()
  if err == io.EOF || err != nil {
     break
  }

  event := response.Event
  // PUBLISH EVENT TO MQTT SERVER ON TOPIC {event owner}/events/{type}
}
```

## Connecting to our new MQTT service
The service has a very pretty landing page (Disclaimer: I am not a designer).

![landing page](/img/blog/mqtt-event-bridge/landing-page.png)

Clicking this button takes you to the login page:

<div class="post-images halves" markdown="1">
![](/img/blog/mqtt-event-bridge/login-enter-phonenumber.png)
![](/img/blog/mqtt-event-bridge/login-pin.png)
</div>

… and then asks you to allow our service to get your voice event and new voicemails. As I am only interested in the voice events here, I’ll only grant that.

As this is an experimental app which hasn’t been approved by anyone, our login page will give you a clear warning about trusting this.

<div class="post-images single" markdown="1">
![](/img/blog/mqtt-event-bridge/login-consent.png)
</div>

When that is done, it returns to our app showing this beautiful UI (still not a designer):

![](/img/blog/mqtt-event-bridge/success.png)

I never bothered to store the credentials in a database, so it should be pretty safe to show you the password.

The following is the output from pasting that mosquitto_sub command in my terminal. It shows that I first called my Swedish number and hanging up before it was actually ringing.

The numbers are redacted, so the actual event does indeed not have that many x’es.

```json
{"event":{"metadata":{"sequence":"1","ackInbox":"_INBOX.VMTx7rnS0i3qXpHfuS5t3b"},"timestamp":"2021-01-06T11:24:40Z","serviceId":"wotel","voiceEvent":{"callId":"0c056e2c-07f9-4c2b-b5ca-042f160af42f","type":"CALL_INITIATED","fromNumber":{"e164":"+47xxxxxxxx"},"toNumber":{"e164":"+46xxxxxxxxx"},"owner":{"e164":"+46xxxxxxxxx"}}}}
{"event":{"metadata":{"sequence":"2","ackInbox":"_INBOX.VMTx7rnS0i3qXpHfuS5t3b"},"timestamp":"2021-01-06T11:24:43Z","serviceId":"wotel","voiceEvent":{"callId":"0c056e2c-07f9-4c2b-b5ca-042f160af42f","type":"CALL_ENDED","fromNumber":{"e164":"+47xxxxxxxx"},"toNumber":{"e164":"+46xxxxxxxxx"},"owner":{"e164":"+46xxxxxxxxx"}}}}
```

If you run any home automation or other hobby projects at home, changes are that you already have a MQTT broker running. You could then setup bridging to not worry about credentials and 
TLS when consuming your events.

## Challenges
We are using phone numbers as your username in this project. As we all know, that is a very fragile identifier as phone numbers will be recycled.

If you get a new number, but the previous owner of that number was already using this service we do not want him to have access to your events.

To keep things simple we simply generate new credentials on every login to avoid any such issues.

## Result
For this project I chose to use Node-RED, as it allows for very quick and easy to show drag-and-drop integrations.

To control the lamp, we did add the module `node-red-contrib-tradfri` ([docs](https://flows.nodered.org/node/node-red-contrib-tradfri) | [GitHub](https://github.com/nidayand/node-red-contrib-tradfri)).

First we did add a `mqtt out` node configured to listen to the topic 46xxxxxxxxx/# with output as a parsed JSON object using the credentials we got on login.

![](/img/blog/mqtt-event-bridge/nodered-debug.png)

We then simply hooked its output to a debug node. Looking at the output, we can see that the event object has a key `voiceEvent`, as this is a voice event.

![](/img/blog/mqtt-event-bridge/nodered-flow.png)

We then simply add a switch for handling it as a voice event if the voiceEvent key exists. Likewise, we do a new switch based on the type field in that event.

Each of those functions simply set the Trådfri payload, as shown below:

```json
{"state":"on","color":"cool daylight"}
```

The finished result can be seen in the video below

<video controls style="width:100%;">
<source src="/video/blog/mqtt-event-bridge/calling.mp4" type="video/mp4">
    Your browser does not support HTML5 video players.
</video>

Here you can see that:
1. When the call is initiated (phone not yet ringing), the light switches to cool white.
2. When the phone is ringing, it turns pink
3. When we answer, it turns red
4. When we hang up, it returns to “normal”.

As this was created quickly as a hackathon project, the intention was never to actually make anything useful. Using this quick flow, it is however clear that it could be very useful for when my wife tries to call me, but I am programming equipped with my noise-cancelling headphones.
